from Imports.imports import *
from UI.ui_components import *
from database.db import conn, cursor

class PDF(FPDF):
    def footer(self):
        self.set_y(-15)
        self.set_font("Arial", "I", 10)
        self.set_text_color(100)
        footer_text = f"Generated by Expense Tracker on {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        self.cell(0, 10, footer_text, 0, 0, 'C')

class ReportsScreen(Screen):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)

    
        # Main Vertical Layout
        main_layout = BoxLayout(orientation='vertical', padding=10, spacing=10)

        # Title Label (Always on top)
        main_layout.add_widget(Label(text="EXPENSE REPORTS", font_size=24, bold=True, size_hint_y=None, height=75))

        # Charts Box (STRICTLY HALF THE SCREEN)
        self.chart_container = BoxLayout(orientation='horizontal', size_hint_y=0.4, spacing=10)
        main_layout.add_widget(self.chart_container)

        # Summary Layout (Centered, fills remaining space)
        self.summary_layout = BoxLayout(orientation='vertical', spacing=5, padding=10, size_hint_y=0.2)
        main_layout.add_widget(self.summary_layout)

        # Lower Section (Filters + Buttons)
        lower_section = BoxLayout(orientation='vertical', size_hint_y=0.4, spacing=10)
        

        # Filters Layout (Period Selection & Date Inputs)
        filter_layout = BoxLayout(size_hint_y=None, height=40, spacing=10)

        # Report Type Dropdown (Half Width)
        self.report_type = ModernSpinner(
            text="Daily",
            values=("Daily", "Weekly", "Monthly", "Yearly", "Custom"),
            size_hint=(0.5, None),
            size=(120, 50)
        )
        filter_layout.add_widget(self.report_type)
        self.report_type.bind(text=self.on_report_type_change)

        # Custom Date Inputs (Evenly Split Other Half)
        date_inputs_layout = BoxLayout(size_hint=(0.5, None), height=40, spacing=10)
        self.start_date_input = TextInput(hint_text="Start Date (YYYY-MM-DD)", size_hint=(0.5, None), size=(140, 50))
        self.end_date_input = TextInput(hint_text="End Date (YYYY-MM-DD)", size_hint=(0.5, None), size=(140, 50))
        self.start_date_input.disabled = True
        self.end_date_input.disabled = True
        date_inputs_layout.add_widget(self.start_date_input)
        date_inputs_layout.add_widget(self.end_date_input)
        filter_layout.add_widget(date_inputs_layout)

        lower_section.add_widget(filter_layout)

        # Button Layout (More Evenly Spaced)
        button_layout = GridLayout(cols=3, spacing=10, size_hint_y=None, height=50)

        # Generate Reports Button
        self.generate_button = Button(text="Generate Report", background_color=(0, 0, 0, 1))
        self.generate_button.bind(on_press=self.generate_reports)
        button_layout.add_widget(self.generate_button)

        # Export CSV Button
        csv_button = Button(text="Export CSV", background_color=(0, 0, 0, 1))
        csv_button.bind(on_press=self.export_csv)
        button_layout.add_widget(csv_button)

        # Export PDF Button
        pdf_button = Button(text="Export PDF", background_color=(0, 0, 0, 1))
        pdf_button.bind(on_press=self.export_pdf)
        button_layout.add_widget(pdf_button)

        lower_section.add_widget(button_layout)

        # Back Button (Smaller Height)
        back_button = Button(text="Back", size_hint_x=1, size_hint_y=None, height=50, background_color=(0, 0, 1, 1))
        back_button.bind(on_press=self.go_back)
        lower_section.add_widget(back_button)

        main_layout.add_widget(lower_section)
        self.add_widget(main_layout)

    
    def on_enter(self):
        # Generate the default report when the screen is entered
        self.generate_reports(None)


    def on_report_type_change(self, spinner, text):
        if text == "Custom":
            self.start_date_input.disabled = False
            self.end_date_input.disabled = False
        else:
            self.start_date_input.disabled = True
            self.end_date_input.disabled = True

    
    

    def generate_reports(self, instance):
        self.chart_container.clear_widgets()
        self.summary_layout.clear_widgets()

        report_type = self.report_type.text
        start_date = self.start_date_input.text
        end_date = self.end_date_input.text
        data = self.fetch_expense_data(report_type, start_date, end_date)

        if data:
            pie_chart, bar_chart = self.create_charts(data)
            self.chart_container.add_widget(FigureCanvasKivyAgg(pie_chart))
            self.chart_container.add_widget(FigureCanvasKivyAgg(bar_chart))

            pie_summary = self.generate_pie_summary(data)
            bar_summary = self.generate_bar_summary(data)


            summaries_box = BoxLayout(orientation='horizontal', spacing=0, padding=(10, 0, 10, 0))

            # Pie Summary Grid
            pie_grid = GridLayout(cols=1, spacing=5, size_hint_x=0.5, padding=(10, 0))

            pie_label = Label(
                text="[b][size=20]PIE CHART SUMMARY[/size][/b]",
                markup=True,
                halign='center',
                size_hint_y=None,
                height=40
            )
            pie_label.bind(size=lambda lbl, s: setattr(lbl, 'text_size', s))
            pie_grid.add_widget(pie_label)

            divider = Label(text="__________________________________", halign='center', size_hint_y=None, height=20)
            divider.bind(size=lambda lbl, s: setattr(lbl, 'text_size', s))
            pie_grid.add_widget(divider)

            for line in pie_summary.strip().split('\n'):
                if line:
                    category, value = line.split(': ', 1) if ': ' in line else ("", line)
                    label = Label(
                        text=f"[b]{category}:[/b] {value}",
                        markup=True,
                        halign='center',
                        valign='middle',
                        size_hint_y=None,
                        height=30
                    )
                    label.bind(size=lambda lbl, s: setattr(lbl, 'text_size', s))
                    pie_grid.add_widget(label)

            # Bar Summary Grid
            bar_grid = GridLayout(cols=1, spacing=5, size_hint_x=0.5, padding=(10, 0))

            bar_label = Label(
                text="[b][size=20]BAR CHART SUMMARY[/size][/b]",
                markup=True,
                halign='center',
                size_hint_y=None,
                height=40
            )
            bar_label.bind(size=lambda lbl, s: setattr(lbl, 'text_size', s))
            bar_grid.add_widget(bar_label)

            divider = Label(text="__________________________________", halign='center', size_hint_y=None, height=20)
            divider.bind(size=lambda lbl, s: setattr(lbl, 'text_size', s))
            bar_grid.add_widget(divider)

            for line in bar_summary.strip().split('\n'):
                if line.strip():
                    if ': ' in line:
                        category, value = line.split(': ', 1)
                        label_text = f"[b]{category}:[/b] {value}"
                    else:
                        label_text = f"[b]{line}[/b]"

                    label = Label(
                        text=label_text,
                        markup=True,
                        halign='center',
                        valign='middle',
                        size_hint_y=None,
                        height=30
                    )
                    label.bind(size=lambda lbl, s: setattr(lbl, 'text_size', s))
                    bar_grid.add_widget(label)

            # Add both summaries to horizontal layout
            summaries_box.add_widget(pie_grid)
            summaries_box.add_widget(bar_grid)

            # Add summary to layout with spacer
            spacer = Label(size_hint_y=None, height=40)
            self.summary_layout.add_widget(spacer)
            self.summary_layout.add_widget(summaries_box)
            self.summary_layout.height = self.summary_layout.minimum_height

        else:
            popup = Popup(
                title="No Data",
                content=Label(text="No expenses found for the selected period."),
                size_hint=(0.6, 0.3)
            )
            popup.open()
            


    def generate_pie_summary(self, data):
        if not data:
            return "No pie chart data available."

        total_expenses = sum(amount for _, amount in data)
        category_summaries = ""

        for category, amount in data:
            percentage = (amount / total_expenses) * 100
            category_summaries += f"{category}: {amount:.2f} ({percentage:.2f}%)\n"


        return f"{category_summaries}"

   

    def generate_bar_summary(self,data):
        conn = sqlite3.connect("expenses.db")
        cursor = conn.cursor()
        report_type = self.report_type.text
        if report_type == "Daily":
            start_date = end_date = datetime.date.today().strftime("%Y-%m-%d")
        elif report_type == "Weekly":
            start_date = (datetime.date.today() - datetime.timedelta(days=7)).strftime("%Y-%m-%d")
            end_date = datetime.date.today().strftime("%Y-%m-%d")
        elif report_type == "Monthly":
            start_date = (datetime.date.today().replace(day=1)).strftime("%Y-%m-%d")
            end_date = datetime.date.today().strftime("%Y-%m-%d")
        elif report_type == "Yearly":
            start_date = (datetime.date.today().replace(month=1, day=1)).strftime("%Y-%m-%d")
            end_date = datetime.date.today().strftime("%Y-%m-%d")
        
        elif report_type == "Custom":
            start_date = self.start_date_input.text
            end_date = self.end_date_input.text
            if not start_date or not end_date:
                popup = Popup(title="Invalid Input",
                            content=Label(text="Please enter both start and end dates."),
                            size_hint=(0.6, 0.3))
                popup.open()
                return
        # Fetch total income
        cursor.execute("SELECT SUM(amount) FROM expenses WHERE expense_type='Income' AND date BETWEEN ? AND ?", (start_date, end_date))
        income_result = cursor.fetchone()
        total_income = income_result[0] if income_result[0] else 0

        # Fetch total expense
        cursor.execute("SELECT SUM(amount) FROM expenses WHERE expense_type='Expense' AND date BETWEEN ? AND ?", (start_date, end_date))
        expense_result = cursor.fetchone()
        total_expense = expense_result[0] if expense_result[0] else 0

        conn.close()

        total = total_income + total_expense

        if total == 0:
            return "No income or expenses to summarize."

        income_percentage = (total_income / total) * 100
        expense_percentage = (total_expense / total) * 100

        return (
            f"Total Income: {total_income:.2f} ({income_percentage:.2f}%)\n"
            f"Total Expense: {total_expense:.2f} ({expense_percentage:.2f}%)"
        )


    
    def fetch_expense_data(self, report_type, start_date, end_date):
        conn = sqlite3.connect("expenses.db")
        cursor = conn.cursor()
        query = """
        SELECT category, SUM(amount)
        FROM expenses
        WHERE date BETWEEN ? AND ?
        GROUP BY category
        ORDER BY category ASC
        """
        if report_type == "Daily":
            start_date = end_date = datetime.date.today().strftime("%Y-%m-%d")
        elif report_type == "Weekly":
            start_date = (datetime.date.today() - datetime.timedelta(days=7)).strftime("%Y-%m-%d")
            end_date = datetime.date.today().strftime("%Y-%m-%d")
        elif report_type == "Monthly":
            start_date = (datetime.date.today().replace(day=1)).strftime("%Y-%m-%d")
            end_date = datetime.date.today().strftime("%Y-%m-%d")
        elif report_type == "Yearly":
            start_date = (datetime.date.today().replace(month=1, day=1)).strftime("%Y-%m-%d")
            end_date = datetime.date.today().strftime("%Y-%m-%d")
        elif report_type == "Custom":
            if not start_date or not end_date:
                popup = Popup(title="Invalid Input",
                            content=Label(text="Please enter both start and end dates."),
                            size_hint=(0.6, 0.3))
                popup.open()
                return


        cursor.execute(query, (start_date, end_date))
        data = cursor.fetchall()
        conn.close()
        return data

    def create_charts(self, data):
        categories, values = zip(*data) if data else ([], [])

        # --- Get real income and expense values ---
        conn = sqlite3.connect("expenses.db")
        cursor = conn.cursor()

        report_type = self.report_type.text
        today = datetime.date.today()

        if report_type == "Daily":
            start_date = end_date = today.strftime("%Y-%m-%d")
        elif report_type == "Weekly":
            start_date = (today - datetime.timedelta(days=7)).strftime("%Y-%m-%d")
            end_date = today.strftime("%Y-%m-%d")
        elif report_type == "Monthly":
            start_date = today.replace(day=1).strftime("%Y-%m-%d")
            end_date = today.strftime("%Y-%m-%d")
        elif report_type == "Yearly":
            start_date = today.replace(month=1, day=1).strftime("%Y-%m-%d")
            end_date = today.strftime("%Y-%m-%d")
        elif report_type == "Custom":
            start_date = self.start_date_input.text
            end_date = self.end_date_input.text
            if not start_date or not end_date:
                popup = Popup(title="Invalid Input",
                            content=Label(text="Please enter both start and end dates."),
                            size_hint=(0.6, 0.3))
                popup.open()
                return

        cursor.execute("SELECT SUM(amount) FROM expenses WHERE expense_type='Income' AND date BETWEEN ? AND ?", (start_date, end_date))
        total_income = cursor.fetchone()[0] or 0

        cursor.execute("SELECT SUM(amount) FROM expenses WHERE expense_type='Expense' AND date BETWEEN ? AND ?", (start_date, end_date))
        total_expense = cursor.fetchone()[0] or 0

        conn.close()

        # --- Pie Chart ---
        fig1, ax1 = plt.subplots(figsize=(5, 5))
        explode = [0.05] * len(values)  # small explosion for all slices

        colors = plt.cm.Set3.colors if len(values) <= 12 else plt.cm.tab20.colors

        wedges, texts, autotexts = ax1.pie(
            values, labels=categories, autopct='%1.1f%%',
            startangle=140, explode=explode, colors=colors,
            textprops={'color': 'white', 'fontsize': 10}
        )

        ax1.set_title("Category-wise Expense Breakdown", color='white', fontsize=14, pad=15)
        ax1.set_facecolor('#262626')
        fig1.patch.set_facecolor('#262626')

        # --- Bar Chart ---
        fig2, ax2 = plt.subplots(figsize=(6, 4))
        bars = ax2.bar(
            ["Total Income", "Total Expense"],
            [total_income, total_expense],
            color=["#00e676", "#ff1744"],
            edgecolor='white',
            width=0.4
        )

        # Add value labels
        for bar in bars:
            height = bar.get_height()
            ax2.text(bar.get_x() + bar.get_width() / 2, height + max(total_income, total_expense) * 0.02,
                    f'{height:.2f}', ha='center', va='bottom', color='white', fontsize=10)

        ax2.set_title("Total Income vs Expense", color='white', fontsize=14, pad=15)
        ax2.set_facecolor('#262626')
        fig2.patch.set_facecolor('#262626')

        ax2.tick_params(axis='x', colors='white')
        ax2.tick_params(axis='y', colors='white')
        ax2.xaxis.label.set_color('white')
        ax2.yaxis.label.set_color('white')
        ax2.spines['bottom'].set_color('white')
        ax2.spines['left'].set_color('white')

        ax2.grid(True, which='major', axis='y', linestyle='--', alpha=0.4)

        return fig1, fig2

    def export_csv(self, instance):
        report_type = self.report_type.text
        if report_type == "Daily":
            start_date = end_date = datetime.date.today().strftime("%Y-%m-%d")
        elif report_type == "Weekly":
            start_date = (datetime.date.today() - datetime.timedelta(days=7)).strftime("%Y-%m-%d")
            end_date = datetime.date.today().strftime("%Y-%m-%d")
        elif report_type == "Monthly":
            start_date = (datetime.date.today().replace(day=1)).strftime("%Y-%m-%d")
            end_date = datetime.date.today().strftime("%Y-%m-%d")
        elif report_type == "Yearly":
            start_date = (datetime.date.today().replace(month=1, day=1)).strftime("%Y-%m-%d")
            end_date = datetime.date.today().strftime("%Y-%m-%d")
        
        elif report_type == "Custom":
            start_date = self.start_date_input.text
            end_date = self.end_date_input.text
            if not start_date or not end_date:
                popup = Popup(title="Invalid Input",
                            content=Label(text="Please enter both start and end dates."),
                            size_hint=(0.6, 0.3))
                popup.open()
                return
        try:
            conn = sqlite3.connect("expenses.db")
            cursor = conn.cursor()

            # Fetch all records ordered by date and time (descending)
            cursor.execute(
            "SELECT date, time, category, amount, description, expense_type "
            "FROM expenses "
            "WHERE date BETWEEN ? AND ? "
            "ORDER BY date DESC, time DESC",
            (start_date, end_date), #parameters for the where clause.
            )
            records = cursor.fetchall()
            conn.close()

            if records:
                filename = f"expense_report_{report_type}_{start_date}_{end_date}.csv"

                # Write data to CSV
                with open(filename, 'w', newline='', encoding='utf-8') as csvfile:
                    writer = csv.writer(csvfile)

                    # Write header
                    writer.writerow(["Date", "Time", "Category", "Amount", "Description", "Expense Type"])
                    writer.writerow(["","","","","",""])
                    # Write rows
                    for row in records:
                        writer.writerow(row)

                self.ask_email_and_send(filename, "csv")

            else:
                popup = Popup(
                    title="No Data",
                    content=Label(text="No expense history to export."),
                    size_hint=(0.6, 0.3)
                )
                popup.open()
        except Exception as e:
            print(f"Error exporting CSV: {e}")
            popup = Popup(
                title="Error",
                content=Label(text="Failed to export CSV."),
                size_hint=(0.6, 0.3)
            )
            popup.open() 




    def export_pdf(self, instance):
        report_type = self.report_type.text
        today = datetime.date.today()

        if report_type == "Daily":
            start_date = end_date = today.strftime("%Y-%m-%d")
        elif report_type == "Weekly":
            start_date = (today - datetime.timedelta(days=7)).strftime("%Y-%m-%d")
            end_date = today.strftime("%Y-%m-%d")
        elif report_type == "Monthly":
            start_date = today.replace(day=1).strftime("%Y-%m-%d")
            end_date = today.strftime("%Y-%m-%d")
        elif report_type == "Yearly":
            start_date = today.replace(month=1, day=1).strftime("%Y-%m-%d")
            end_date = today.strftime("%Y-%m-%d")
        elif report_type == "Custom":
            start_date = self.start_date_input.text
            end_date = self.end_date_input.text
            if not start_date or not end_date:
                Popup(title="Invalid Input", content=Label(text="Please enter both start and end dates."), size_hint=(0.6, 0.3)).open()
                return

        data = self.fetch_expense_data(report_type, start_date, end_date)

        conn = sqlite3.connect("expenses.db")
        cursor = conn.cursor()
        cursor.execute("SELECT SUM(amount) FROM expenses WHERE expense_type='Income' AND date BETWEEN ? AND ?", (start_date, end_date))
        total_income = cursor.fetchone()[0] or 0

        cursor.execute("SELECT SUM(amount) FROM expenses WHERE expense_type='Expense' AND date BETWEEN ? AND ?", (start_date, end_date))
        total_expense = cursor.fetchone()[0] or 0

        cursor.execute(
            "SELECT date, time, category, amount, description, expense_type "
            "FROM expenses "
            "WHERE date BETWEEN ? AND ? "
            "ORDER BY date DESC, time DESC",
            (start_date, end_date),
        )
        records = cursor.fetchall()
        conn.close()

        if not (data or total_income or total_expense):
            Popup(title="No Data", content=Label(text="No data found for the selected period."), size_hint=(0.6, 0.3)).open()
            return

        pie_chart, bar_chart = self.create_charts(data)
        pie_path, bar_path = "pie_chart.png", "bar_chart.png"
        pie_chart.savefig(pie_path, bbox_inches='tight')
        bar_chart.savefig(bar_path, bbox_inches='tight')
        pie_chart.clf()
        bar_chart.clf()

        pdf = PDF()
        pdf.set_auto_page_break(auto=True, margin=20)
        pdf.add_page()

        pdf.set_draw_color(0, 0, 0)
        pdf.rect(5, 5, 200, 287)

        pdf.set_font("Arial", "B", 20)
        pdf.cell(0, 15, "Expense Report", ln=True, align="C")
        pdf.set_font("Arial", "", 12)
        pdf.cell(0, 10, f"{report_type} | {start_date} to {end_date}", ln=True, align="C")
        pdf.line(10, pdf.get_y(), 200, pdf.get_y())
        pdf.ln(8)

        pdf.set_font("Arial", "B", 14)
        pdf.cell(0, 10, "Category-wise Expenses:", ln=True)
        pdf.set_font("Arial", "", 12)
        pie_summary = self.generate_pie_summary(data)
        for line in pie_summary.strip().split('\n'):
            pdf.cell(0, 8, line.strip(), ln=True)

        pdf.ln(5)
        pdf.set_font("Arial", "B", 14)
        pdf.cell(0, 10, "Income vs Expense Summary:", ln=True)
        pdf.set_font("Arial", "", 12)
        total = total_income + total_expense
        income_percent = (total_income / total) * 100 if total else 0
        expense_percent = (total_expense / total) * 100 if total else 0
        pdf.cell(0, 8, f"Total Income  : Rs. {total_income:.2f} ({income_percent:.2f}%)", ln=True)
        pdf.cell(0, 8, f"Total Expense : Rs. {total_expense:.2f} ({expense_percent:.2f}%)", ln=True)

        pdf.ln(10)
        pdf.set_font("Arial", "B", 14)
        pdf.cell(0, 10, "Charts:", ln=True)
        y_start = pdf.get_y()
        pdf.image(pie_path, x=15, y=y_start + 5, w=85)
        pdf.image(bar_path, x=110, y=y_start + 5, w=85)
        pdf.set_y(y_start + 95)

        pdf.add_page()
        pdf.set_draw_color(0, 0, 0)
        pdf.rect(5, 5, 200, 287)

        pdf.set_font("Arial", "B", 14)
        pdf.cell(0, 10, "Detailed Transaction History", ln=True)
        pdf.set_font("Arial", "B", 10)
        headers = ["Date", "Time", "Category", "Amount", "Description", "Type"]
        col_widths = [25, 20, 30, 25, 60, 25]

        for i, header in enumerate(headers):
            pdf.cell(col_widths[i], 8, header, border=1, align='C')
        pdf.ln()
        pdf.set_font("Arial", "", 10)

        for row in records:
            if pdf.get_y() > 265:
                pdf.add_page()
                pdf.set_draw_color(0, 0, 0)
                pdf.rect(5, 5, 200, 287)
                pdf.set_font("Arial", "B", 10)
                for i, header in enumerate(headers):
                    pdf.cell(col_widths[i], 8, header, border=1, align='C')
                pdf.ln()
                pdf.set_font("Arial", "", 10)

            for i, item in enumerate(row):
                text = str(item)
                if i == 4 and len(text) > 40:
                    text = text[:37] + "..."
                pdf.cell(col_widths[i], 8, text, border=1)
            pdf.ln()

        filename = f"expense_report_{report_type}_{start_date}_{end_date}.pdf"
        pdf.output(filename)
        self.ask_email_and_send(filename, "pdf")



        
    def send_email_with_attachment(self, recipient_email, filename, filetype):
        try:
            msg = EmailMessage()
            msg['Subject'] = f'Expense Report - {filetype.upper()}'
            msg['From'] = "aravindm4567@gmail.com"  # Replace with your sender email
            msg['To'] = recipient_email
            msg.set_content(f"Please find attached your expense report in {filetype.upper()} format.")

            with open(filename, 'rb') as f:
                file_data = f.read()
                file_name = f.name

            maintype = 'application'
            subtype = 'pdf' if filetype == 'pdf' else 'csv'

            msg.add_attachment(file_data, maintype=maintype, subtype=subtype, filename=file_name)

            with smtplib.SMTP_SSL('smtp.gmail.com', 465) as smtp:
                smtp.login("aravindm4567@gmail.com", "zzaq hijb xaek uxnp")  # Replace with actual
                smtp.send_message(msg)

            Popup(title="Email Sent",
                content=Label(text="Report emailed successfully."),
                size_hint=(0.6, 0.3)).open()

        except Exception as e:
            print(f"Email error: {e}")
            Popup(title="Email Failed",
                content=Label(text="Failed to send email."),
                size_hint=(0.6, 0.3)).open()
            
    def ask_email_and_send(self, filename, filetype):
        layout = BoxLayout(orientation='vertical', spacing=10, padding=10)
        email_input = TextInput(hint_text="Enter recipient email", multiline=False, size_hint_y=None, height=40)
        layout.add_widget(email_input)

        def send_file(_):
            email = email_input.text.strip()
            if email:
                self.send_email_with_attachment(email, filename, filetype)
                popup.dismiss()
            else:
                email_input.hint_text = "Email required!"

        send_btn = Button(text="Send", size_hint_y=None, height=40)
        send_btn.bind(on_press=send_file)
        layout.add_widget(send_btn)

        popup = Popup(title="Send Report via Email",
                    content=layout,
                    size_hint=(0.5, 0.25))
        popup.open()






    def go_back(self, instance):
        self.manager.current = 'main'
